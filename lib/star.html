<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Star Garden</title>
<link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400&family=Space+Mono&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    width: 100vw; height: 100vh;
    overflow: hidden;
    background: #000;
    font-family: 'Cormorant Garamond', serif;
    user-select: none;
  }

  #skyCanvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 1;
  }

  #drawCanvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 2;
    cursor: crosshair;
  }

  #ui {
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 10;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 24px 32px;
    pointer-events: none;
  }

  .title-block {
    opacity: 0;
    animation: fadeIn 1.5s ease forwards 0.3s;
  }
  .title-block h1 {
    font-size: 2.2rem;
    font-weight: 300;
    color: #b0c8e8;
    letter-spacing: 0.15em;
    text-transform: uppercase;
  }
  .title-block p {
    font-family: 'Space Mono', monospace;
    font-size: 0.6rem;
    color: #3e5e8a;
    letter-spacing: 0.25em;
    margin-top: 6px;
    text-transform: uppercase;
  }

  .stats {
    text-align: right;
    opacity: 0;
    animation: fadeIn 1.5s ease forwards 0.6s;
  }
  .stats .count {
    font-size: 2.8rem;
    font-weight: 300;
    color: #dde8ff;
    line-height: 1;
  }
  .stats .label {
    font-family: 'Space Mono', monospace;
    font-size: 0.58rem;
    color: #3e5e8a;
    letter-spacing: 0.25em;
    text-transform: uppercase;
  }

  #hint {
    position: fixed;
    bottom: 36px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    font-family: 'Space Mono', monospace;
    font-size: 0.68rem;
    color: #3a5a8a;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    pointer-events: none;
    animation: fadeIn 1.5s ease forwards 1s, pulse 3s ease-in-out infinite;
    opacity: 0;
    transition: opacity 0.5s;
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(-8px); }
    to { opacity: 1; transform: translateY(0); }
  }
  @keyframes pulse {
    0%,100% { opacity: 0.35; }
    50% { opacity: 0.75; }
  }
</style>
</head>
<body>

<canvas id="skyCanvas"></canvas>
<canvas id="drawCanvas"></canvas>

<div id="ui">
  <div class="title-block">
    <h1>Star Garden</h1>
    <p>Draw a star shape to plant it in the sky</p>
  </div>
  <div class="stats">
    <div class="count" id="starCount">0</div>
    <div class="label">Stars grown</div>
  </div>
</div>

<div id="hint">draw a star with your finger or mouse</div>

<script>
const skyC = document.getElementById('skyCanvas');
const skyCtx = skyC.getContext('2d');
const drawC = document.getElementById('drawCanvas');
const drawCtx = drawC.getContext('2d');
const countEl = document.getElementById('starCount');
const hintEl = document.getElementById('hint');

let W, H;
function resize() {
  W = skyC.width = drawC.width = window.innerWidth;
  H = skyC.height = drawC.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Background dust
const dust = [];
for (let i = 0; i < 150; i++) {
  dust.push({
    x: Math.random() * 3000,
    y: Math.random() * 2000,
    r: Math.random() * 1.1 + 0.2,
    a: Math.random() * 0.35 + 0.05,
    phase: Math.random() * Math.PI * 2
  });
}

// Placed stars
const placedStars = [];

class PlacedStar {
  constructor(cx, cy, outerR, innerR, points, rotation, hue) {
    this.x = cx;
    this.y = cy;
    this.outerR = outerR;
    this.innerR = innerR;
    this.points = points;
    this.rotation = rotation;
    this.hue = hue;
    this.rotSpeed = (Math.random() - 0.5) * 0.003;
    this.pulsePhase = Math.random() * Math.PI * 2;
    this.scale = 0;
    this.targetScale = 1;
    this.twinkleSpeed = 0.015 + Math.random() * 0.02;
    this.particles = [];
    const pCount = 15 + Math.floor(outerR * 1.5);
    for (let i = 0; i < pCount; i++) {
      const ang = Math.random() * Math.PI * 2;
      const spd = Math.random() * 2.5 + 0.5;
      this.particles.push({
        x: cx, y: cy,
        vx: Math.cos(ang) * spd,
        vy: Math.sin(ang) * spd,
        life: 1,
        decay: 0.005 + Math.random() * 0.01,
        r: Math.random() * 2.5 + 0.5
      });
    }
  }

  update() {
    this.scale += (this.targetScale - this.scale) * 0.07;
    this.rotation += this.rotSpeed;
    this.pulsePhase += this.twinkleSpeed;
  }

  draw(ctx) {
    this.update();
    const pulse = 1 + Math.sin(this.pulsePhase) * 0.06;
    const s = this.scale * pulse;
    const oR = this.outerR * s;
    const iR = this.innerR * s;

    // Glow
    const glowR = oR * 5;
    const glow = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowR);
    glow.addColorStop(0, `hsla(${this.hue}, 60%, 80%, 0.2)`);
    glow.addColorStop(0.3, `hsla(${this.hue}, 50%, 70%, 0.06)`);
    glow.addColorStop(1, `hsla(${this.hue}, 40%, 60%, 0)`);
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(this.x, this.y, glowR, 0, Math.PI * 2);
    ctx.fill();

    // Star shape
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);

    ctx.beginPath();
    for (let i = 0; i < this.points * 2; i++) {
      const angle = (i * Math.PI) / this.points - Math.PI / 2;
      const r = i % 2 === 0 ? oR : iR;
      if (i === 0) ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
      else ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
    }
    ctx.closePath();

    const fg = ctx.createRadialGradient(0, 0, 0, 0, 0, oR);
    fg.addColorStop(0, `hsla(${this.hue}, 25%, 97%, 1)`);
    fg.addColorStop(0.35, `hsla(${this.hue}, 55%, 82%, 0.9)`);
    fg.addColorStop(1, `hsla(${this.hue}, 65%, 60%, 0.7)`);
    ctx.fillStyle = fg;
    ctx.fill();

    ctx.strokeStyle = `hsla(${this.hue}, 50%, 92%, 0.35)`;
    ctx.lineWidth = 0.7;
    ctx.stroke();

    ctx.restore();

    // Particles
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.985;
      p.vy *= 0.985;
      p.life -= p.decay;
      if (p.life <= 0) { this.particles.splice(i, 1); continue; }
      ctx.fillStyle = `hsla(${this.hue}, 65%, 85%, ${p.life * 0.5})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r * p.life, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// === DRAWING ===
let isDrawing = false;
let drawPoints = [];
let drawTrail = [];

function getPos(e) {
  if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
  return { x: e.clientX, y: e.clientY };
}

function startDraw(e) {
  e.preventDefault();
  isDrawing = true;
  drawPoints = [];
  drawTrail = [];
  const p = getPos(e);
  drawPoints.push(p);
  drawTrail.push({ ...p, life: 1 });
  hintEl.style.opacity = '0';
}

function moveDraw(e) {
  if (!isDrawing) return;
  e.preventDefault();
  const p = getPos(e);
  // Only add if moved enough
  const last = drawPoints[drawPoints.length - 1];
  if (Math.hypot(p.x - last.x, p.y - last.y) > 2) {
    drawPoints.push(p);
    drawTrail.push({ ...p, life: 1 });
  }
}

function endDraw(e) {
  if (!isDrawing) return;
  e.preventDefault();
  isDrawing = false;

  if (drawPoints.length < 8) {
    drawPoints = [];
    return;
  }

  const star = analyzeAndCreateStar(drawPoints);
  if (star) {
    placedStars.push(star);
    countEl.textContent = placedStars.length;
  }
  drawPoints = [];
}

drawC.addEventListener('mousedown', startDraw);
drawC.addEventListener('mousemove', moveDraw);
drawC.addEventListener('mouseup', endDraw);
drawC.addEventListener('mouseleave', endDraw);
drawC.addEventListener('touchstart', startDraw, { passive: false });
drawC.addEventListener('touchmove', moveDraw, { passive: false });
drawC.addEventListener('touchend', endDraw, { passive: false });

// === ANALYZE DRAWING â†’ STAR ===
function analyzeAndCreateStar(pts) {
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const p of pts) {
    minX = Math.min(minX, p.x);
    maxX = Math.max(maxX, p.x);
    minY = Math.min(minY, p.y);
    maxY = Math.max(maxY, p.y);
  }

  const cx = (minX + maxX) / 2;
  const cy = (minY + maxY) / 2;
  const w = maxX - minX;
  const h = maxY - minY;
  const size = Math.max(w, h);

  if (size < 15) return null;

  // Distances from center
  const dists = pts.map(p => Math.hypot(p.x - cx, p.y - cy));
  const maxDist = Math.max(...dists);
  const minDist = Math.min(...dists.filter(d => d > 5));
  const avgDist = dists.reduce((a, b) => a + b, 0) / dists.length;

  // Count peaks (far from center) to estimate points
  let peaks = 0;
  let wasFar = false;
  for (let i = 0; i < dists.length; i++) {
    const isFar = dists[i] > avgDist * 1.05;
    if (isFar && !wasFar) peaks++;
    wasFar = isFar;
  }

  let starPoints = Math.max(3, Math.min(8, peaks));
  if (starPoints < 3) starPoints = 5;

  // Size proportional to drawing
  const outerR = Math.max(14, Math.min(65, size * 0.42));
  const ratio = minDist / (maxDist || 1);
  const innerR = outerR * Math.max(0.25, Math.min(0.55, ratio * 0.9));

  // Angle from first point
  const firstPt = pts[0];
  const rot = Math.atan2(firstPt.y - cy, firstPt.x - cx) + Math.PI / 2;

  // Hue: position-based with variety
  const hue = (200 + (cx / W) * 80 + (cy / H) * 40 + Math.random() * 30) % 360;

  return new PlacedStar(cx, cy, outerR, innerR, starPoints, rot, hue);
}

// === RENDER ===
let frame = 0;

function render() {
  frame++;

  // Sky
  skyCtx.clearRect(0, 0, W, H);

  const bg = skyCtx.createRadialGradient(W * 0.3, H * 0.85, 0, W * 0.5, H * 0.5, Math.max(W, H));
  bg.addColorStop(0, '#0b1c33');
  bg.addColorStop(0.35, '#060f1e');
  bg.addColorStop(1, '#010509');
  skyCtx.fillStyle = bg;
  skyCtx.fillRect(0, 0, W, H);

  // Nebula wisps
  const nb1 = skyCtx.createRadialGradient(W * 0.15, H * 0.25, 0, W * 0.15, H * 0.25, 350);
  nb1.addColorStop(0, 'rgba(12, 35, 75, 0.18)');
  nb1.addColorStop(1, 'rgba(0,0,0,0)');
  skyCtx.fillStyle = nb1;
  skyCtx.fillRect(0, 0, W, H);

  const nb2 = skyCtx.createRadialGradient(W * 0.8, H * 0.65, 0, W * 0.8, H * 0.65, 280);
  nb2.addColorStop(0, 'rgba(18, 28, 65, 0.14)');
  nb2.addColorStop(1, 'rgba(0,0,0,0)');
  skyCtx.fillStyle = nb2;
  skyCtx.fillRect(0, 0, W, H);

  // Dust
  for (const d of dust) {
    d.phase += 0.012;
    const a = d.a * (0.35 + Math.sin(d.phase) * 0.65);
    skyCtx.fillStyle = `rgba(130, 160, 210, ${Math.max(0, a)})`;
    skyCtx.beginPath();
    skyCtx.arc(d.x % W, d.y % H, d.r, 0, Math.PI * 2);
    skyCtx.fill();
  }

  // Stars
  for (const star of placedStars) {
    star.draw(skyCtx);
  }

  // === Draw canvas ===
  drawCtx.clearRect(0, 0, W, H);

  // Fading trail
  for (let i = drawTrail.length - 1; i >= 0; i--) {
    const t = drawTrail[i];
    t.life -= 0.03;
    if (t.life <= 0) { drawTrail.splice(i, 1); continue; }

    drawCtx.fillStyle = `rgba(180, 210, 255, ${t.life * 0.45})`;
    drawCtx.beginPath();
    drawCtx.arc(t.x, t.y, 2 * t.life + 0.8, 0, Math.PI * 2);
    drawCtx.fill();

    drawCtx.fillStyle = `rgba(140, 180, 255, ${t.life * 0.1})`;
    drawCtx.beginPath();
    drawCtx.arc(t.x, t.y, 10 * t.life, 0, Math.PI * 2);
    drawCtx.fill();
  }

  // Active stroke
  if (isDrawing && drawPoints.length > 1) {
    drawCtx.strokeStyle = 'rgba(200, 225, 255, 0.85)';
    drawCtx.lineWidth = 2.2;
    drawCtx.lineCap = 'round';
    drawCtx.lineJoin = 'round';
    drawCtx.shadowColor = 'rgba(140, 190, 255, 0.7)';
    drawCtx.shadowBlur = 12;
    drawCtx.beginPath();
    drawCtx.moveTo(drawPoints[0].x, drawPoints[0].y);
    for (let i = 1; i < drawPoints.length; i++) {
      drawCtx.lineTo(drawPoints[i].x, drawPoints[i].y);
    }
    drawCtx.stroke();
    drawCtx.shadowBlur = 0;
  }

  requestAnimationFrame(render);
}

requestAnimationFrame(render);
</script>
</body>
</html>



